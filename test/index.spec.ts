import { describe, it, assert, beforeAll } from 'vitest'
import { loadKZG } from '../src/index.js'
import { bytesToHex, hexToBytes } from '../src/util.js'

const BYTES_PER_FIELD_ELEMENT = 32
const FIELD_ELEMENTS_PER_BLOB = 4096
const BYTES_PER_BLOB = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB
const CELLS_PER_EXT_BLOB = 128
const BYTES_PER_CELL = 2048
const BYTES_PER_G1 = 48

describe('kzg initialization', () => {
  let kzg: any
  beforeAll(async () => {
    kzg = await loadKZG()
  })

  it('should initialize', async () => {
    assert.typeOf(kzg.computeBlobKZGProof, 'function', 'initialized KZG object')
    kzg.freeTrustedSetup()
  })

  it('should throw when invalid trusted setup is provided', () => {
    assert.throws(() => {
      kzg.loadTrustedSetup({ g1_monomial: 'x12',  g1_lagrange: 'bad coordinates', g2_monomial: 'x12'})
    })
  })
})

describe('kzg API tests', () => {
  let kzg: Awaited<ReturnType<typeof loadKZG>>
  beforeAll(async () => {
    kzg = await loadKZG()
    const result = kzg.loadTrustedSetup()
    assert.equal(result, 0, 'loaded trusted setup successfully')
  })

  it('should generate kzg commitments and verify proofs', async () => {
    const blob = new Uint8Array(BYTES_PER_BLOB)
    blob[0] = 0x01
    blob[1] = 0x02
    const commitment = kzg.blobToKZGCommitment(bytesToHex(blob))
    assert.equal(commitment.slice(2).toLowerCase(), 'ab87358a111c3cd9da8aadf4b414e9f6be5ac83d923fb70d8d27fef1e2690b4cad015b23b8c058881da78a05c62b1173')
    const proof = kzg.computeBlobKZGProof(bytesToHex(blob), (commitment))
    assert.equal(proof.toLowerCase(), '0x8dd951edb4e0df1779c29d28b835a2cc8b26ebf69a38d7d9afadd0eb8a4cbffd9db1025fd253e91e00a9904f109e81e3')
    const proofVerified = kzg.verifyBlobKZGProofBatch([bytesToHex(blob)], [(commitment)], [proof])
    assert.equal(proofVerified, true)
  })

  it('should verify kzg proofs with points', async () => {
    const precompileData = {
      Proof: (
        '0xc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
      ),
      Commitment: (
        '0xc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'
      ),
      z: (
        '0x623ce31cf9759a5c8daf3a357992f9f3dd7f9339d8998bc8e68373e54f00b75e'
      ),
      y: (
        '0x0000000000000000000000000000000000000000000000000000000000000000'
      ),
    }

    const verifiedKZGProof = kzg.verifyKZGProof(precompileData.Commitment, precompileData.z, precompileData.y, precompileData.Proof)
    assert.equal(verifiedKZGProof, true)
  })

  it('should calculate cells and kzg proofs', async () => {
    // Create a simple test blob with valid field elements
    const blob = new Uint8Array(BYTES_PER_BLOB)
    blob[0] = 0x01
    blob[1] = 0x02
    const blobHex = bytesToHex(blob)

    // Compute cells and proofs for the blob
    const cellsAndProofsHex = kzg.computeCellsAndKZGProofs(blobHex)

    assert(cellsAndProofsHex.proof == "0x81D4F75E60CD7628B00D09E3E5D0F4A64111E76D090106AB49451A796E1BEDF59950080C36E24C759CF929EC59FC0E11")
    assert(cellsAndProofsHex.cells.length == CELLS_PER_EXT_BLOB)
    assert(cellsAndProofsHex.cells[0].startsWith("0x8014AB72EBA259E250DB1A183C151F791F3488CD210B013D48C5115AEE96548F48944BC3B186B6E0A389DF20828C62D8829BC5A03EDFB5CFC76C0057AF9DF89828DBEFD7D3A6972C3E5E2C6A5B6F2B9BC994549D32F4D3451C92DD35B3B155E984D2C3B4BB62FDB32909243242B3AE31D22F992EFEDC37721C75A7A013D810DCF326C6048B2B8F87F810243A6AA3D4CB8BFA9AADAC91879663E69CC0837829798D6D9B6A289D16DCCC8041A553E28F0710EDF8D72EAE6BF4E691C2197EE8E75F960FEFB7E687E03CAE287D0C07D88DDDD73E90D32B5248C4A833AEC3007D52F7E9CB0477CD7E7F29E1CC4CB18EDD2DBD87E3EDD4BA39E504041F514A8658CF78C935A3C9E51507CDB268061D70CA17F6FA89BDA767019AFD55F499877466AFEAB53CDBCE26AD0EF70E29FDC8C2B1BBA965DB4D51CB35BB857D06251700F6B377AF546F14EE6167275ADD4FEC7E5F2E43B0406DD18549A5D36BE7D8F1E1903ED105471150E18FDDFC7334000DAA99479196364CA79609CFCE0A13B5D51CEF8BFCA64BBB4463B00B5B9E8AA07A00FD666841AA9C944ECD913B41E1C274D4021DFADEFE449B36646C426B31D1EA81091796A77D0EB9FA3040C0CD2E18A8AD07679090C4A7F71B1FF8E90716DE96DAAD1CF56654FDC0C509583679B58ED6E8EED2FF8A33814F358B79BAAA511CB3310CA8B76DAF06A1F9F7551AED84B50D3218FAC8E63526EB662D851C4B46C95717DFE6739682C06F7C0F3E79A487D15BE64530CB6C80909DC6026E5182BBB816A557915765ACC673FB6956BEB7DD0367867A180B923AD04C96DDA5BDF2F57482FC2BE19D8304AD6FBA0C8EAF5B85AB4AB04A2DEEE97F39AEF5542BF2325676DCC2E83001A8BFD69D1C119C42539569EF674CB774E696A3077DCD4B01C64E4CD5E9BF62BD646D746C817CD25EAC3831DC0A9CF3EE97E1A6AFD777D758A55A47EC0693ABADED968AA8D3A2E030C43D809D72DD388F29D8454C26095B56D2AB1EE65C7D7612B77AD44E30EA85D62DD0ABBA588A30B5202FFAE613CDA3FBB8E20CECBC4EFBD03E3CFDBDAFC9194284AA04F2C3B2724495DB2814533419EF1808FFA43CABFF8699A03231A464C388A57C950E9F34B65B8D8424F63F09BB348FAF41FC0A88AD7CB46DF4871BC41DBD4166DA9D93E28F2C46A7974BD2B5F4E04F06964D1DA8E9702F4D18774389AB677B6689BD4FD11DAB90EE4338390AAACEE628C97BEC0ADBFC10D869D480EF009704E2BBE9D3EEA1EE082942867F3037999DF1BD51638A909F81BB994C11AFBA4B6D8E44FF7B0E674B1F51EB0585FCE23C3B054A5C71C724110592B1CA781EB51464E9C608BF547285A73AB5C5F958355F87F607D9D7180FBB088F744BABF2F0F1BD2E6649060DCD7046651CE44FA1B0C73FF404C9A77499F0AF3A460E7B531A876333D2D0BC869D4973FAC3A6859EAEF4F"))

  })
})
